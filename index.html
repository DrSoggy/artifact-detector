<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>STALKER-style Artifact Detector (Cosplay)</title>
<style>
  :root{
    --bg:#0b0b0b;
    --panel:#071006;
    --green-screen: #042b05;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#050505,#0b0b0b);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#cfe9c7;}
  .wrap{max-width:720px;margin:20px auto;padding:14px;box-sizing:border-box;}
  .detector{display:flex;gap:12px;align-items:flex-start;justify-content:center;flex-direction:column;width:100%;}
  .frame{
    width:100%;
    max-width:420px;
    margin:0 auto;
    padding:12px;
    border-radius:12px;
    background:linear-gradient(180deg,#8a6b48 0%, #634b36 20%, #2c241e 90%);
    box-shadow: 0 8px 30px rgba(0,0,0,0.7);
    border:4px solid rgba(0,0,0,0.2);
    position:relative;
    overflow:hidden;
  }
  .frame:after{
    content:'';
    position:absolute;left:0;right:0;top:0;bottom:0;border-radius:12px;
    background:
      radial-gradient(circle at 10% 20%, rgba(0,0,0,0.05) 0, transparent 10%),
      radial-gradient(circle at 80% 80%, rgba(255,180,120,0.03) 0, transparent 18%);
    pointer-events:none;
  }

  .screen-wrap{
    background:linear-gradient(180deg,#05260b,#011204);
    padding:10px;border-radius:8px;display:flex;align-items:center;justify-content:center;
    position:relative;
  }
  canvas{display:block;border-radius:6px;background:transparent;touch-action:none;user-select:none;-webkit-user-select:none;}

  /* CRT / analog overlay */
  .screen-wrap::before{
    content:"";
    position:absolute;left:0;right:0;top:0;bottom:0;border-radius:6px;
    pointer-events:none;
    background:
      repeating-linear-gradient(to bottom, rgba(0,0,0,0.02), rgba(0,0,0,0.02) 2px, rgba(0,0,0,0.00) 3px),
      linear-gradient(180deg, rgba(0,0,0,0.06), rgba(0,0,0,0.12));
    mix-blend-mode: overlay;
    opacity:0.75;
  }
  .screen-wrap::after{
    /* subtle noise / scan glow */
    content:"";
    position:absolute;left:0;right:0;top:0;bottom:0;border-radius:6px;
    pointer-events:none;
    background:
      radial-gradient(ellipse at center, rgba(0,255,120,0.04) 0%, rgba(0,0,0,0.4) 60%);
    mix-blend-mode: screen;
    opacity:0.9;
  }

  .controls{display:flex;align-items:center;justify-content:space-between;margin-top:12px;gap:8px;}
  .left-controls{display:flex;align-items:center;gap:8px;}
  .led{width:18px;height:18px;border-radius:50%;background:#2b0b0b;box-shadow:0 0 10px rgba(0,0,0,0.6) inset;border:2px solid #2b0000;display:inline-block;vertical-align:middle;transition:all 0.08s linear;}
  .led.on{background:linear-gradient(180deg,#ff3b3b,#9b0000);box-shadow:0 0 8px rgba(255,60,60,0.95), 0 0 20px rgba(255,60,60,0.25);border-color:#3a0000;}
  .right-controls{display:flex;align-items:center;gap:8px;}
  /* plain circular green button */
  button.green{
    width:36px;height:36px;border-radius:50%;background:linear-gradient(180deg,#2ee06a,#1c8b47);color:#052007;padding:0;border-radius:50%;border:0;font-weight:700;box-shadow: 0 6px 20px rgba(0,0,0,0.4);display:inline-flex;align-items:center;justify-content:center;
  }
  button.green:active{transform:translateY(1px)}
  .sliders{display:flex;flex-direction:column;gap:8px;margin-top:12px;}
  label{font-size:13px;color:#b8eab1}
  input[type=range]{width:100%}
  /* info overlay inside frame (top-left) */
  .info{
    position:absolute;
    top:12px;
    left:12px;
    width:44%;
    min-width:140px;
    max-width:220px;
    background:rgba(0,0,0,0.36);
    padding:8px 10px;border-radius:8px;color:#dfffe0;font-size:13px;
    box-shadow:0 6px 14px rgba(0,0,0,0.6);
    display:none;
    z-index:5;
  }
  .info h3{margin:0 0 6px 0;color:#dfffe0;font-size:15px}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .badge{background:rgba(0,0,0,0.18);padding:6px 8px;border-radius:6px;font-size:12px;}
  @media (max-width:420px){
    .frame{padding:8px}
    .led{width:16px;height:16px}
    button.green{width:32px;height:32px}
    .info{width:52%;font-size:12px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="detector">
    <div class="frame" id="frame">
      <div class="screen-wrap">
        <canvas id="radar" width="360" height="360" style="width:100%;height:100%"></canvas>
      </div>

      <div class="controls">
        <div class="left-controls">
          <div id="led" class="led" title="Proximity LED"></div>
          <div style="margin-left:8px;font-size:13px;color:#a8dca8">LED</div>
        </div>

        <div class="right-controls">
          <button id="randBtn" class="green" title="Randomise"></button>
        </div>
      </div>

      <div class="sliders">
        <div>
          <label>Proximity <span id="proxVal">50</span></label>
          <input id="proximity" type="range" min="0" max="100" value="50">
        </div>
        <div>
          <label>Direction <span id="dirVal">0°</span></label>
          <input id="direction" type="range" min="0" max="100" value="0">
        </div>
      </div>

      <div class="info" id="info">
        <h3 id="artifactName">Artifact</h3>
        <div class="row" style="margin-bottom:6px">
          <div class="badge" id="atype">Type: ?</div>
          <div class="badge" id="rarity">Rarity: ?</div>
          <div class="badge" id="price">Price: ?</div>
        </div>
        <div style="font-size:12px" id="energy">Energy: ?%</div>
        <div style="margin-top:6px;font-size:12px" id="stats"></div>
      </div>

    </div>
  </div>
</div>

<script>
/* Updated detector per user request */

/* CONFIG */
const SWEEP_SPEED = 8.0;       // degrees per frame (faster)
const DETECT_ARC = 30;         // degrees wide detection arc (larger)
const LERP = 0.12;             // smoothing for movement
const MIN_BEEP_INTERVAL = 80;  // ms at proximity near 100 (fast)
const MAX_BEEP_INTERVAL = 1800;// ms at proximity near 0 (slow)
const BEEP_DURATION = 70;      // ms beep length
const FADE_MS = 1800;          // fade-out in ms for artifact after detection

/* UI refs */
const canvas = document.getElementById('radar');
const ctx = canvas.getContext('2d');
const proximityEl = document.getElementById('proximity');
const directionEl = document.getElementById('direction');
const proxValEl = document.getElementById('proxVal');
const dirValEl = document.getElementById('dirVal');
const ledEl = document.getElementById('led');
const randBtn = document.getElementById('randBtn');

const infoPanel = document.getElementById('info');
const artifactNameEl = document.getElementById('artifactName');
const typeEl = document.getElementById('atype');
const rarityEl = document.getElementById('rarity');
const priceEl = document.getElementById('price');
const energyEl = document.getElementById('energy');
const statsEl = document.getElementById('stats');

/* Canvas sizing - force square based on available width */
function sizeCanvas(){
  const pad = 24; // frame padding etc
  const maxW = Math.min(window.innerWidth - pad, 420);
  const size = Math.floor(maxW);
  const dpr = Math.max(window.devicePixelRatio || 1, 1);
  canvas.style.width = size + 'px';
  canvas.style.height = size + 'px';
  canvas.width = size * dpr;
  canvas.height = size * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', sizeCanvas);
sizeCanvas();

/* state */
let sweepAngle = 0;
let artifact = { angleDeg:0, proximity: Number(proximityEl.value), meta: null };
let current = { angleDeg: artifact.angleDeg, proximity: artifact.proximity };
let lastDetectedAt = 0;
let visibleAlpha = 0;

/* audio */
let audioCtx = null;
let beepTimer = null;
let continuousOsc = null;
let continuousGain = null;
let isAudioEnabled = false;

/* artifact database */
const names = ["Krovavaya","Siren","Mire","Tesla","Viper","Lump","Echo","Glimmer","Cvar","Nexus","Shard","Wisp"];
const types = ["Electro","Gravity","Thermal","Bio","Psy","Rad"];
const rarities = [
  {name:"Common",mult:1,prob:50},
  {name:"Uncommon",mult:1.6,prob:30},
  {name:"Rare",mult:2.4,prob:15},
  {name:"Artifact",mult:4.5,prob:4},
  {name:"Unique",mult:8.0,prob:1}
];

function weightedRandom(arr){
  const sum = arr.reduce((s,i)=>s+i.prob,0);
  const r = Math.random()*sum;
  let s=0;
  for(const a of arr){ s+=a.prob; if(r<=s) return a; }
  return arr[0];
}

/* audio helpers */
function ensureAudio(){
  if(audioCtx) return;
  try{
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }catch(e){
    audioCtx = null;
  }
}
function playBeep(){
  if(!audioCtx) return;
  const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.value = 800 + (artifact.meta?.energy || 0) * 2;
  g.gain.value = 0;
  o.connect(g); g.connect(audioCtx.destination);
  const dur = BEEP_DURATION / 1000;
  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.18, t + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
  o.start(t);
  o.stop(t + dur + 0.02);
}

/* Continuous tone for proximity 100 */
function startContinuousTone(){
  if(!audioCtx || continuousOsc) return;
  continuousOsc = audioCtx.createOscillator();
  continuousGain = audioCtx.createGain();
  continuousOsc.type = 'sine';
  continuousOsc.frequency.value = 950;
  continuousGain.gain.value = 0.0;
  continuousOsc.connect(continuousGain); continuousGain.connect(audioCtx.destination);
  continuousOsc.start();
  // fade-in small
  continuousGain.gain.linearRampToValueAtTime(0.18, audioCtx.currentTime + 0.05);
}
function stopContinuousTone(){
  if(!continuousOsc) return;
  try{
    continuousGain.gain.linearRampToValueAtTime(0.0001, audioCtx.currentTime + 0.02);
    setTimeout(()=>{ try{ continuousOsc.stop(); continuousOsc.disconnect(); continuousGain.disconnect(); }catch(e){} continuousOsc = null; continuousGain = null; }, 80);
  }catch(e){ continuousOsc = null; continuousGain = null; }
}

/* schedule repeating beep (for 0<prox<100) */
function scheduleRepeatingBeep(){
  // clear existing
  if(beepTimer) { clearTimeout(beepTimer); beepTimer = null; }
  if(!isAudioEnabled || !audioCtx) return;
  const p = artifact.proximity;
  if(p <= 0 || p >= 100) return;
  const interval = proxToInterval(p);
  function beat(){
    // blink
    ledEl.classList.add('on');
    playBeep();
    setTimeout(()=>{ if(artifact.proximity < 100) ledEl.classList.remove('on'); }, Math.max(60, BEEP_DURATION));
    // schedule next using current proximity
    const nextInterval = proxToInterval(artifact.proximity);
    beepTimer = setTimeout(beat, nextInterval);
  }
  beepTimer = setTimeout(beat, proxToInterval(artifact.proximity));
}

function proxToInterval(p){
  // linear map so closer -> smaller interval
  const ratio = clamp(p/100,0,1);
  // mapping invert: at 0 -> MAX, at 100 -> MIN
  return Math.round(MAX_BEEP_INTERVAL - (MAX_BEEP_INTERVAL - MIN_BEEP_INTERVAL) * ratio);
}

function manageAudioState(){
  if(!isAudioEnabled || !audioCtx) return;
  // stop any continuous if not needed
  if(artifact.proximity >= 100){
    // ensure continuous tone on and LED permanently on
    if(beepTimer){ clearTimeout(beepTimer); beepTimer = null; }
    startContinuousTone();
    ledEl.classList.add('on');
  } else if(artifact.proximity > 0){
    // stop continuous
    stopContinuousTone();
    ledEl.classList.remove('on'); // blinking will be applied on beat
    if(beepTimer){ clearTimeout(beepTimer); beepTimer = null; }
    scheduleRepeatingBeep();
  } else {
    // no proximity -> no beep, LED off
    if(beepTimer){ clearTimeout(beepTimer); beepTimer = null; }
    stopContinuousTone();
    ledEl.classList.remove('on');
  }
}

/* randomize artifact: sets meta, angle, and sets proximity to 0 (far) */
function randomizeArtifact(){
  const baseName = names[Math.floor(Math.random()*names.length)];
  const type = types[Math.floor(Math.random()*types.length)];
  const rarityObj = weightedRandom(rarities);
  const energy = Math.floor(20 + Math.random()*80); // 20..100
  const basePrice = Math.floor(300 + Math.random()*1700);
  const price = Math.round(basePrice * rarityObj.mult * (0.7 + Math.random()*0.6) * (energy/100 + 0.5));
  const stats = {
    radiation: (Math.random()*12).toFixed(1)+" rads",
    weight: (0.2 + Math.random()*4).toFixed(2) + " kg",
    // power removed per request
  };
  artifact.meta = { name: baseName, type, rarity: rarityObj.name, price, energy, stats };
  // set far
  artifact.proximity = 0;
  proximityEl.value = 0; proxValEl.textContent = 0;
  // random angle (bearing) but map to our slider logic
  const angle = Math.random()*360;
  artifact.angleDeg = angle;
  // compute slider value such that (val/100)*360 - 90 = angle  => val = ((angle+90)/360)*100
  const sliderVal = ((angle + 90) % 360) / 360 * 100;
  directionEl.value = Math.round(sliderVal);
  dirValEl.textContent = displayDegreesFromSlider(directionEl.value);
  updateInfoUI();
  manageAudioState();
}

/* Info UI */
function updateInfoUI(){
  if(!artifact.meta) return;
  artifactNameEl.textContent = artifact.meta.name;
  typeEl.textContent = "Type: " + artifact.meta.type;
  rarityEl.textContent = "Rarity: " + artifact.meta.rarity;
  priceEl.textContent = "Price: " + artifact.meta.price + " RU";
  energyEl.textContent = "Energy: " + artifact.meta.energy + "%";
  statsEl.innerHTML = Object.entries(artifact.meta.stats).map(([k,v])=>`<div><strong>${k}:</strong> ${v}</div>`).join('');
}

/* Helpers */
function degToRad(d){ return d * Math.PI/180; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function lerp(a,b,t){ return a + (b-a)*t; }
function angleDiff(a,b){ let d = (((a - b + 540) % 360) - 180); return d; }
function lerpAngle(a,b,t){ const diff = angleDiff(b,a); return (a + diff * t + 360) % 360; }
function displayDegreesFromSlider(sliderVal){
  // show 0..360 where 0 and 360 are both front
  const deg = Math.round((sliderVal/100)*360);
  return (deg === 360) ? "360°" : deg + "°";
}

/* Event listeners */
proximityEl.addEventListener('input',(e)=>{
  const val = Number(e.target.value);
  artifact.proximity = val;
  proxValEl.textContent = val;
  manageAudioState();
});
directionEl.addEventListener('input',(e)=>{
  const val = Number(e.target.value);
  dirValEl.textContent = displayDegreesFromSlider(val);
  // slider->angle mapping: angleDeg = (val/100)*360 - 90
  artifact.angleDeg = (val/100)*360 - 90;
});

/* Randomize button (user gesture to enable audio); sets proximity to 0 (far) */
randBtn.addEventListener('click', (e)=>{
  ensureAudio();
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  isAudioEnabled = true;
  randomizeArtifact();
});

/* also allow touchstart to enable audio by interaction */
document.addEventListener('touchstart', function once(){
  ensureAudio();
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  isAudioEnabled = true;
  document.removeEventListener('touchstart', once);
}, {passive:true});

/* DRAW */
function draw(){
  // smoothing
  current.proximity = lerp(current.proximity, artifact.proximity, LERP);
  current.angleDeg = lerpAngle(current.angleDeg, artifact.angleDeg, LERP);

  // canvas params
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  const size = Math.min(w,h);
  const cx = size/2;
  const cy = size/2;
  const maxR = size*0.38;

  ctx.clearRect(0,0, size, size);

  // radar circle
  const g = ctx.createRadialGradient(cx,cy,10,cx,cy,maxR);
  g.addColorStop(0, "rgba(3,40,8,0.95)");
  g.addColorStop(0.6, "rgba(6,60,12,0.6)");
  g.addColorStop(1, "rgba(1,20,4,0.75)");
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.arc(cx,cy,maxR,0,Math.PI*2);
  ctx.fill();

  // concentric rings
  ctx.lineWidth = 1;
  ctx.strokeStyle = "rgba(0,160,70,0.12)";
  for(let i=1;i<=4;i++){
    ctx.beginPath();
    ctx.arc(cx,cy,maxR*(i/4),0,Math.PI*2);
    ctx.stroke();
  }

  // crosshair faint
  ctx.strokeStyle = "rgba(0,200,100,0.06)";
  ctx.beginPath();
  ctx.moveTo(cx-maxR,cy); ctx.lineTo(cx+maxR,cy);
  ctx.moveTo(cx,cy-maxR); ctx.lineTo(cx,cy+maxR);
  ctx.stroke();

  // sweep arm
  sweepAngle += SWEEP_SPEED;
  if(sweepAngle >= 360) sweepAngle -= 360;
  const sweepA = degToRad(sweepAngle);
  ctx.save();
  ctx.translate(cx,cy);
  const armLen = maxR;
  const armGrad = ctx.createLinearGradient(0,0, Math.cos(sweepA)*armLen, Math.sin(sweepA)*armLen);
  armGrad.addColorStop(0, "rgba(0,255,120,0.28)");
  armGrad.addColorStop(1, "rgba(0,255,60,0.02)");
  ctx.rotate(sweepA);
  ctx.fillStyle = armGrad;
  ctx.beginPath();
  // slightly thicker arm for CRT effect
  ctx.moveTo(0,0);
  ctx.arc(0,0, armLen, degToRad(-8), degToRad(8));
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // artifact position
  // compute detection: slider->angle mapping used earlier: note artifact.angleDeg is already in canvas coords
  const artifactAngle = current.angleDeg;
  const diff = angleDiff(sweepAngle, artifactAngle);
  const visibleNow = Math.abs(diff) <= DETECT_ARC;

  // compute distance: proximity 100 => center (dist 0)
  const dist = maxR * (1 - (current.proximity/100));
  const aRad = degToRad(artifactAngle);
  const ax = cx + Math.cos(aRad)*dist;
  const ay = cy + Math.sin(aRad)*dist;

  // fading logic: when sweep passes set lastDetectedAt
  if(visibleNow){
    lastDetectedAt = Date.now();
    visibleAlpha = 1;
    // if detected by sweep, show info for a while and update UI
    updateInfoUI();
  } else {
    // compute alpha decay based on lastDetectedAt
    const since = Date.now() - lastDetectedAt;
    visibleAlpha = Math.max(0, 1 - (since / FADE_MS));
  }

  // draw artifact dot with alpha
  if(visibleAlpha > 0.02){
    ctx.beginPath();
    ctx.fillStyle = `rgba(100,255,140,${0.95 * visibleAlpha})`;
    ctx.arc(ax,ay,6 * (0.9 + 0.15*Math.sin(Date.now()/120)),0,Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.strokeStyle = `rgba(100,255,140,${0.18 * visibleAlpha})`;
    ctx.arc(ax,ay,12 * (1.0 + 0.08*Math.sin(Date.now()/120)),0,Math.PI*2);
    ctx.stroke();
  }

  // center marker
  ctx.fillStyle = "rgba(0,0,0,0.3)";
  ctx.beginPath();
  ctx.arc(cx,cy,6,0,Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = "rgba(0,255,140,0.5)";
  ctx.beginPath();
  ctx.arc(cx,cy,6,0,Math.PI*2);
  ctx.stroke();

  // Show info panel when found (prox ~100) OR recently detected by sweep
  if(current.proximity > 98 || visibleAlpha > 0.02){
    infoPanel.style.display = 'block';
  } else {
    infoPanel.style.display = 'none';
  }

  // LED state when continuous proximity reached (kept in manageAudioState), but ensure DOM reflects it
  // (Blinking handled in audio callbacks)

  requestAnimationFrame(draw);
}

/* Start up */
randomizeArtifact(); // initial artifact
updateInfoUI();
draw();

/* manage audio periodically in case proximity is updated programmatically */
setInterval(()=>{ manageAudioState(); }, 350);

/* helper: ensure slider->angle mapping consistent for changes outside UI */
proximityEl.addEventListener('change', ()=>{ artifact.proximity = Number(proximityEl.value); manageAudioState(); });
directionEl.addEventListener('change', ()=>{
  artifact.angleDeg = (Number(directionEl.value)/100)*360 - 90;
});

/* small utility to clamp */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
</script>
</body>
</html>
