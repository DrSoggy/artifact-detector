<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>STALKER Artifact Detector — Final</title>

<!-- Techy display font -->
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#060606;
    --frame1:#7b5b3f;
    --frame2:#4f3726;
    --panel:#021005;
    --accent:#0ff08a;
    --muted:#a8dca8;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#020202,#0b0b0b);font-family:Orbitron,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--muted);display:flex;align-items:center;justify-content:center;}
  .wrap{width:100%;max-width:460px;padding:16px;box-sizing:border-box;display:flex;align-items:center;justify-content:center;}
  .frame{
    width:100%;border-radius:14px;padding:12px;box-sizing:border-box;
    background:
      radial-gradient(1200px 600px at 10% 10%, rgba(255,200,120,0.03), transparent 6%),
      linear-gradient(180deg,var(--frame1), var(--frame2));
    box-shadow: 0 12px 36px rgba(0,0,0,0.7);
    border:4px solid rgba(0,0,0,0.22);position:relative;overflow:visible;
  }

  /* rusty texture */
  .frame::before{
    content:"";position:absolute;inset:0;border-radius:14px;
    background-image:
      radial-gradient(circle at 8% 12%, rgba(255,190,120,0.06), transparent 6%),
      radial-gradient(circle at 82% 78%, rgba(255,160,90,0.04), transparent 12%),
      repeating-linear-gradient(135deg, rgba(0,0,0,0.02) 0 2px, transparent 2px 6px);
    pointer-events:none;mix-blend-mode: overlay;
  }

  .screen-wrap{background: linear-gradient(180deg,#042b10,#02160a);padding:10px;border-radius:10px;display:flex;align-items:center;justify-content:center;position:relative;overflow:visible;}
  canvas{display:block;border-radius:8px;background:transparent;touch-action:none;-webkit-tap-highlight-color:transparent;}

  /* CRT overlay */
  .screen-wrap::after{
    content:"";position:absolute;inset:0;border-radius:8px;pointer-events:none;
    background: repeating-linear-gradient(to bottom, rgba(0,0,0,0.03) 0 2px, rgba(0,0,0,0.00) 2px 4px), linear-gradient(180deg, rgba(0,0,0,0.06), rgba(0,0,0,0.14));
    mix-blend-mode: overlay;opacity:0.92;
  }

  /* crack drawn with pseudo-element (visible even when power off) */
  .crack{
    position:absolute;right:14px;top:8px;width:110px;height:110px;pointer-events:none;z-index:12;
  }

  .controls{display:flex;align-items:center;justify-content:space-between;margin-top:10px;gap:8px;}
  .left-controls{display:flex;align-items:center;gap:8px;}
  .led{width:18px;height:18px;border-radius:50%;background:#2b0b0b;border:2px solid #2b0000;box-shadow:0 0 8px rgba(0,0,0,0.6) inset;transition:all 0.08s linear;}
  .led.on{background:linear-gradient(180deg,#ff3b3b,#9b0000);box-shadow:0 0 12px rgba(255,60,60,0.95),0 0 24px rgba(255,60,60,0.22);border-color:#3a0000;}
  .right-controls{display:flex;align-items:center;gap:8px;}
  button.green{width:40px;height:40px;border-radius:50%;background:linear-gradient(180deg,#2ee06a,#1c8b47);border:0;box-shadow:0 8px 20px rgba(0,0,0,0.45);display:inline-flex;align-items:center;justify-content:center;padding:0;color:#052007;font-weight:700;}
  button.green:active{transform:translateY(1px)}

  button.power{margin:10px auto 6px auto;display:block;width:84px;height:36px;border-radius:8px;background:linear-gradient(180deg,#ff6b2b,#d4491a);border:0;color:#fff;font-weight:800;box-shadow:0 10px 30px rgba(0,0,0,0.45);cursor:pointer}
  button.power.off{filter:grayscale(55%) brightness(0.6)}

  .sliders{display:flex;flex-direction:column;gap:8px;margin-top:12px;}
  label{font-size:13px;color:#b8eab1}
  input[type=range]{width:100%}

  .info{position:absolute;left:10px;top:10px;z-index:6;background:rgba(0,0,0,0.34);padding:6px 8px;border-radius:8px;color:#dfffe0;font-size:12px;min-width:110px;max-width:180px;box-shadow:0 6px 14px rgba(0,0,0,0.6);display:none}
  .info h3{margin:0 0 6px 0;font-size:14px}
  .row{display:flex;gap:6px;flex-wrap:wrap}
  .badge{background:rgba(0,0,0,0.18);padding:4px 6px;border-radius:6px;font-size:12px;color:var(--muted);border:1px solid rgba(0,255,140,0.06)}
  .badge.uncommon{color:#9fffae;border-color:rgba(120,255,140,0.12)}
  .badge.rare{color:#a9d6ff;border-color:rgba(120,190,255,0.12)}
  .badge.legendary{color:#ffd868;border-color:rgba(255,210,110,0.18)}

  .panel-fake{position:absolute;z-index:7; font-size:11px; color:#cbdcbd; font-family:Orbitron,monospace}
  .fake-top-left{left:18px;top:4px}
  .fake-top-right{right:18px;top:4px; text-align:right}
  .fake-bottom-left{left:18px;bottom:12px}
  .fake-bottom-right{right:18px;bottom:12px;text-align:right}

  /* power overlay dims screen but crack sits above it */
  .power-off-overlay{position:absolute;left:10px;right:10px;top:10px;bottom:10px;border-radius:8px;background:rgba(0,0,0,0.96);z-index:10;display:block;pointer-events:none}
  .power-off-overlay.hidden{display:none}

  @media (max-width:420px){
    .frame{padding:8px}
    .led{width:16px;height:16px}
    button.green{width:36px;height:36px}
    .info{min-width:100px;max-width:150px;font-size:12px}
    button.power{width:72px;height:34px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="frame" id="frame">

    <div class="screen-wrap" id="screenWrap">
      <canvas id="radar" width="520" height="520" style="width:100%;max-width:420px;height:auto"></canvas>

      <!-- crack SVG in top-right (always visible) -->
      <div class="crack" aria-hidden="true">
        <svg viewBox="0 0 120 120" width="120" height="120" preserveAspectRatio="xMaxYMin">
          <g stroke="rgba(200,200,200,0.55)" stroke-width="1.2" fill="none" stroke-linecap="round">
            <path d="M94 6 L85 18 L92 28 L82 30 L74 40 L82 48" stroke-opacity="0.9"/>
            <path d="M96 12 L110 26" stroke-opacity="0.5"/>
            <path d="M86 22 L100 35" stroke-opacity="0.35"/>
            <path d="M92 34 L108 50" stroke-opacity="0.2"/>
            <path d="M74 22 L64 36 L66 48 L56 58" stroke-opacity="0.25"/>
          </g>
        </svg>
      </div>

      <!-- info (shows only at found) -->
      <div class="info" id="info">
        <h3 id="artifactName">—</h3>
        <div class="row" style="margin-bottom:6px">
          <div id="atype" class="badge">Type: —</div>
          <div id="rarity" class="badge">Rarity: —</div>
          <div id="price" class="badge">Price: —</div>
        </div>
        <div id="energy" style="font-size:12px;margin-bottom:6px">Energy: —%</div>
        <div id="stats" style="font-size:12px"></div>
      </div>

      <!-- small fake UI bits for realism -->
      <div class="panel-fake fake-top-left">MODE: SCAN</div>
      <div class="panel-fake fake-top-right">BAT: 76%</div>
      <div class="panel-fake fake-bottom-left">SENS: HIGH</div>
      <div class="panel-fake fake-bottom-right">SIG: —</div>

      <div class="power-off-overlay" id="powerOverlay"></div>
    </div>

    <div class="controls" style="margin-top:10px;">
      <div class="left-controls">
        <div id="led" class="led" title="Proximity LED"></div>
        <div style="margin-left:8px;font-size:13px;color:#a8dca8">LED</div>
      </div>

      <div class="right-controls">
        <button id="randBtn" class="green" title="Randomize">R</button>
      </div>
    </div>

    <button id="powerBtn" class="power off">ON</button>

    <div class="sliders">
      <div>
        <label>Proximity <span id="proxVal">50</span></label>
        <input id="proximity" type="range" min="0" max="100" value="50">
      </div>
      <div>
        <label>Direction <span id="dirVal">0°</span></label>
        <input id="direction" type="range" min="0" max="100" value="0">
      </div>
    </div>

  </div>
</div>

<script>
/* Final revisions:
 - single triangle front wedge + trailing smear strictly behind the front
 - slider mapping: slider middle = front, ends = behind (0/100 -> behind)
 - beeps & LED driven by RAF so they continue while dragging
 - energy 30-100%
 - click sound on power button
 - additional fake indicators added
 - crack SVG sits above everything visible when off
 - ON button label remains "ON" always; visual state via .off class
 - uses Orbitron font loaded from Google Fonts (fallback available)
*/

const canvas = document.getElementById('radar');
const ctx = canvas.getContext('2d');
const proximityEl = document.getElementById('proximity');
const directionEl = document.getElementById('direction');
const proxValEl = document.getElementById('proxVal');
const dirValEl = document.getElementById('dirVal');
const ledEl = document.getElementById('led');
const randBtn = document.getElementById('randBtn');

const infoPanel = document.getElementById('info');
const artifactNameEl = document.getElementById('artifactName');
const typeEl = document.getElementById('atype');
const rarityEl = document.getElementById('rarity');
const priceEl = document.getElementById('price');
const energyEl = document.getElementById('energy');
const statsEl = document.getElementById('stats');
const powerBtn = document.getElementById('powerBtn');
const powerOverlay = document.getElementById('powerOverlay');

let dpr = Math.max(window.devicePixelRatio || 1, 1);
function sizeCanvas(){
  const maxW = Math.min(window.innerWidth - 48, 420);
  const cssSize = Math.floor(maxW);
  canvas.style.width = cssSize + 'px';
  canvas.style.height = cssSize + 'px';
  canvas.width = cssSize * dpr;
  canvas.height = cssSize * dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', sizeCanvas);
sizeCanvas();

/* CONFIG */
let SWEEP_SPEED = 5.0;   // a bit faster
const TRAIL_STEPS = 20;
const TRAIL_STEP_ANGLE = 3.4;
const DETECT_ARC = 28;
const LERP = 0.12;
const FADE_MS = 900;
const MIN_BEEP_INTERVAL = 80;
const MAX_BEEP_INTERVAL = 2200;
const BEEP_DURATION = 70;

/* audio */
let audioCtx = null;
let continuousOsc = null;
let continuousGain = null;
let isAudioEnabled = false;
let powerOn = false; // starts OFF visually
let lastBeepTime = 0;
let ledFlashUntil = 0;

/* db */
const names = ["Krovavaya","Siren","Mire","Tesla","Viper","Lump","Echo","Glimmer","Cvar","Nexus","Shard","Wisp"];
const types = ["Electro","Gravity","Thermal","Bio","Psy","Rad"];
const rarities = [
  {name:"Common",prob:60, base:1500, cls:''},
  {name:"Uncommon",prob:30, base:3500, cls:'uncommon'},
  {name:"Rare",prob:9, base:8000, cls:'rare'},
  {name:"Legendary",prob:1, base:50000, cls:'legendary'}
];
function weightedRandom(arr){
  const sum = arr.reduce((s,i)=>s+i.prob,0);
  const r = Math.random()*sum;
  let s=0;
  for(const a of arr){ s+=a.prob; if(r<=s) return a; }
  return arr[0];
}

/* state */
let sweepAngle = 0;
let artifact = { angleDeg:0, proximity: Number(proximityEl.value), meta: null };
let current = { angleDeg: artifact.angleDeg, proximity: artifact.proximity };
let lastDetectedAt = -999999;
let visibleAlpha = 0;

/* audio helpers */
function ensureAudio(){
  if(audioCtx) return;
  try{ audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch(e){ audioCtx = null; }
}
function playBeep(){
  if(!audioCtx || !powerOn) return;
  const t = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.value = 680 + (artifact.meta?.energy || 0) * 1.6;
  g.gain.value = 0;
  o.connect(g); g.connect(audioCtx.destination);
  const dur = BEEP_DURATION / 1000;
  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.15, t + 0.008);
  g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
  o.start(t);
  o.stop(t + dur + 0.02);
}
function startContinuousTone(){
  if(!audioCtx || !powerOn || continuousOsc) return;
  continuousOsc = audioCtx.createOscillator();
  continuousGain = audioCtx.createGain();
  continuousOsc.type = 'sine';
  continuousOsc.frequency.value = 920;
  continuousGain.gain.value = 0.0;
  continuousOsc.connect(continuousGain); continuousGain.connect(audioCtx.destination);
  continuousOsc.start();
  continuousGain.gain.linearRampToValueAtTime(0.18, audioCtx.currentTime + 0.05);
}
function stopContinuousTone(){
  if(!continuousOsc) return;
  try{
    continuousGain.gain.linearRampToValueAtTime(0.0001, audioCtx.currentTime + 0.02);
    setTimeout(()=>{ try{ continuousOsc.stop(); continuousOsc.disconnect(); continuousGain.disconnect(); }catch(e){} continuousOsc=null; continuousGain=null; }, 80);
  }catch(e){ continuousOsc=null; continuousGain=null; }
}

/* price compute (gentle modifiers; energy 30..100 enforced) */
function computePrice(meta){
  if(!meta) return 0;
  const base = meta._base;
  const energyFactor = 1 + (meta.energy * 0.006); // stronger effect (up to ~0.6)
  const weightFactor = 1 + (meta.weight * 0.012);
  const radPenalty = Math.max(0.6, 1 - (meta.radiation * 0.0055));
  const randomVar = 0.92 + Math.random() * 0.16;
  let price = Math.round(base * energyFactor * weightFactor * radPenalty * randomVar);
  price = Math.max(100, price);
  return price;
}

/* randomize artifact (energy 30-100) */
function randomizeArtifact(){
  const baseName = names[Math.floor(Math.random()*names.length)];
  const type = types[Math.floor(Math.random()*types.length)];
  const rarityObj = weightedRandom(rarities);
  const energy = Math.floor(30 + Math.random()*70); // 30..100
  const weight = +( (0.2 + Math.random()*5.8).toFixed(2) );
  const radiation = +( (Math.random()*24).toFixed(1) );
  const meta = { name: baseName, type, rarity: rarityObj.name, energy, weight, radiation, _base: rarityObj.base };
  meta.price = computePrice(meta);
  artifact.meta = meta;
  artifact.proximity = 0;
  proximityEl.value = 0; proxValEl.textContent = 0;
  lastDetectedAt = -999999; visibleAlpha = 0;
  const angle = Math.random()*360;
  artifact.angleDeg = angle;
  let sliderVal = (((angle - 180 + 360) % 360) / 360) * 100;
  directionEl.value = Math.round(sliderVal);
  dirValEl.textContent = Math.round((directionEl.value/100)*360) + "° (slider)";
  updateInfoUI();
}

/* update info fields (prepared but shown only at found) */
function updateInfoUI(){
  if(!artifact.meta) return;
  artifactNameEl.textContent = artifact.meta.name;
  typeEl.textContent = "Type: " + artifact.meta.type;
  rarityEl.textContent = "Rarity: " + artifact.meta.rarity;
  priceEl.textContent = "Price: " + artifact.meta.price + " RU";
  energyEl.textContent = "Energy: " + artifact.meta.energy + "%";
  statsEl.innerHTML = `<div><strong>Weight:</strong> ${artifact.meta.weight} kg</div><div><strong>Radiation:</strong> ${artifact.meta.radiation} rads</div>`;
  rarityEl.className = 'badge';
  const rarObj = rarities.find(r=>r.name === artifact.meta.rarity);
  if(rarObj && rarObj.name === 'Legendary') rarityEl.classList.add('legendary');
  if(rarObj && rarObj.name === 'Rare') rarityEl.classList.add('rare');
  if(rarObj && rarObj.name === 'Uncommon') rarityEl.classList.add('uncommon');
}

/* mapping: slider center -> front(0deg), ends -> behind(180deg) */
function sliderToAngle(sliderVal){
  // sliderVal 0..100 -> angle = ((50 - sliderVal)/50)*180  -> -180..180 then normalized
  const a = ((50 - sliderVal)/50) * 180;
  const norm = (a + 360) % 360;
  return norm;
}

/* UI events */
proximityEl.addEventListener('input', (e)=>{
  artifact.proximity = Number(e.target.value);
  proxValEl.textContent = artifact.proximity;
  if(artifact.proximity <= 0){ lastDetectedAt = -999999; visibleAlpha = 0; }
});
directionEl.addEventListener('input', (e)=>{
  const sv = Number(e.target.value);
  dirValEl.textContent = Math.round((sv/100)*360) + "° (slider)";
  artifact.angleDeg = sliderToAngle(sv);
});

/* power button (always labeled ON) */
powerBtn.addEventListener('click', ()=>{
  powerOn = !powerOn;
  // toggle visual class only, label stays "ON"
  if(powerOn){ powerBtn.classList.remove('off'); powerOverlay.classList.add('hidden'); ensureAudio(); if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); isAudioEnabled = true; }
  else { powerBtn.classList.add('off'); powerOverlay.classList.remove('hidden'); stopContinuousTone(); isAudioEnabled = false; ledEl.classList.remove('on'); }
  // click sound either way
  clickSound();
});

/* randomize button acts as user gesture and spawns new artifact (far) */
randBtn.addEventListener('click', ()=>{
  ensureAudio();
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  isAudioEnabled = true;
  randomizeArtifact();
});

/* initial touch to unlock audio */
document.addEventListener('touchstart', function once(){
  ensureAudio();
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
  isAudioEnabled = true;
  document.removeEventListener('touchstart', once);
}, {passive:true});

/* click sound function */
function clickSound(){
  if(!audioCtx) { ensureAudio(); if(!audioCtx) return; }
  try{
    const t = audioCtx.currentTime;
    const o1 = audioCtx.createOscillator();
    const g1 = audioCtx.createGain();
    o1.type = 'triangle';
    o1.frequency.value = 900;
    g1.gain.value = 0.001;
    o1.connect(g1); g1.connect(audioCtx.destination);
    g1.gain.setValueAtTime(0.001, t);
    g1.gain.linearRampToValueAtTime(0.18, t + 0.012);
    g1.gain.exponentialRampToValueAtTime(0.0001, t + 0.06);
    o1.start(t);
    o1.stop(t + 0.08);
  }catch(e){}
}

/* beep interval mapping */
function proxToInterval(p){
  const ratio = Math.max(0, Math.min(1, p/100));
  return Math.round(MAX_BEEP_INTERVAL - (MAX_BEEP_INTERVAL - MIN_BEEP_INTERVAL) * ratio);
}

/* DRAW loop */
let noiseTime = 0;
function draw(now){
  sizeCanvas();
  const cssW = canvas.clientWidth;
  const cssH = canvas.clientHeight;
  const size = Math.min(cssW, cssH);
  const cx = size/2; const cy = size/2;
  const maxR = size*0.42;

  current.proximity = lerp(current.proximity, artifact.proximity, LERP);
  current.angleDeg = lerpAngle(current.angleDeg, artifact.angleDeg, LERP);

  ctx.clearRect(0,0,size,size);

  // radar background circle
  const g = ctx.createRadialGradient(cx,cy,8,cx,cy,maxR);
  g.addColorStop(0, "rgba(2,40,8,0.98)");
  g.addColorStop(0.6, "rgba(8,70,18,0.6)");
  g.addColorStop(1, "rgba(2,20,6,0.9)");
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(cx,cy,maxR,0,Math.PI*2); ctx.fill();

  // rings
  ctx.lineWidth = 1;
  ctx.strokeStyle = "rgba(0,180,90,0.11)";
  for(let i=1;i<=4;i++){ ctx.beginPath(); ctx.arc(cx,cy,maxR*(i/4),0,Math.PI*2); ctx.stroke(); }

  // faint crosshair
  ctx.strokeStyle = "rgba(0,220,120,0.06)";
  ctx.beginPath(); ctx.moveTo(cx-maxR,cy); ctx.lineTo(cx+maxR,cy); ctx.moveTo(cx,cy-maxR); ctx.lineTo(cx,cy+maxR); ctx.stroke();

  // CRT scanlines
  ctx.save();
  for(let y = cy - maxR; y <= cy + maxR; y += 2.2){
    const dx = Math.sqrt(Math.max(0, maxR*maxR - (y-cy)*(y-cy)));
    ctx.strokeStyle = `rgba(0,0,0,${0.02 + 0.02*Math.sin((y+noiseTime*12)/40)})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx-dx, y); ctx.lineTo(cx+dx,y); ctx.stroke();
  }
  ctx.restore();

  // Sweep: draw trailing smear strictly behind the front wedge
  sweepAngle = (sweepAngle + SWEEP_SPEED) % 360;

  // draw older trail (behind) first with blur to smooth
  ctx.save();
  ctx.translate(cx,cy);
  for(let i=TRAIL_STEPS;i>0;i--){
    const stepAngle = sweepAngle - i * TRAIL_STEP_ANGLE;
    const alpha = Math.max(0, 0.42 * (1 - i / TRAIL_STEPS));
    // apply blur for older parts
    if(i > (TRAIL_STEPS*0.45)) ctx.filter = 'blur(6px)';
    else ctx.filter = 'none';
    const a = degToRad(stepAngle);
    const halfWidth = degToRad(10);
    const grad = ctx.createLinearGradient(Math.cos(a)*0, Math.sin(a)*0, Math.cos(a)*maxR, Math.sin(a)*maxR);
    grad.addColorStop(0, `rgba(0,255,120,${alpha})`);
    grad.addColorStop(1, `rgba(0,255,80,${alpha*0.02})`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.arc(0,0, maxR, a - halfWidth, a + halfWidth);
    ctx.closePath();
    ctx.globalCompositeOperation = 'lighter';
    ctx.fill();
  }
  ctx.restore();
  ctx.filter = 'none';
  ctx.globalCompositeOperation = 'source-over';

  // draw solid front wedge (no blur) to make a clear front edge
  ctx.save(); ctx.translate(cx,cy);
  const aFront = degToRad(sweepAngle);
  const halfFront = degToRad(9);
  const gradFront = ctx.createLinearGradient(Math.cos(aFront)*0, Math.sin(aFront)*0, Math.cos(aFront)*maxR, Math.sin(aFront)*maxR);
  gradFront.addColorStop(0, "rgba(0,255,150,0.98)");
  gradFront.addColorStop(1, "rgba(0,255,80,0.06)");
  ctx.fillStyle = gradFront;
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.arc(0,0, maxR, aFront - halfFront, aFront + halfFront);
  ctx.closePath();
  ctx.globalCompositeOperation = 'lighter';
  ctx.fill();
  ctx.restore();

  // artifact only visible if proximity > 0
  if(artifact.proximity > 0){
    const artifactAngle = current.angleDeg;
    const diff = angleDiff(sweepAngle, artifactAngle);
    const visibleNow = Math.abs(diff) <= DETECT_ARC;
    const dist = maxR * (1 - (current.proximity/100));
    const aRad = degToRad(artifactAngle);
    const ax = cx + Math.cos(aRad)*dist;
    const ay = cy + Math.sin(aRad)*dist;

    if(visibleNow){
      lastDetectedAt = Date.now();
      visibleAlpha = 1;
    } else {
      const since = Date.now() - lastDetectedAt;
      visibleAlpha = Math.max(0, 1 - (since / FADE_MS));
    }

    if(visibleAlpha > 0.02){
      ctx.beginPath();
      ctx.fillStyle = `rgba(100,255,140,${0.95 * visibleAlpha})`;
      const pulse = 1.0 + 0.12 * Math.sin(Date.now()/120);
      ctx.arc(ax,ay,6 * pulse,0,Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.strokeStyle = `rgba(100,255,140,${0.18 * visibleAlpha})`;
      ctx.arc(ax,ay,12 * pulse,0,Math.PI*2);
      ctx.stroke();
    }
  } else {
    lastDetectedAt = -999999; visibleAlpha = 0;
  }

  // center marker
  ctx.beginPath(); ctx.fillStyle = "rgba(0,0,0,0.28)"; ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.strokeStyle = "rgba(0,255,140,0.5)"; ctx.arc(cx,cy,6,0,Math.PI*2); ctx.stroke();

  // info display logic: only show at found (>=100) and when powered on
  if(Math.round(current.proximity) >= 100 && artifact.meta && powerOn){
    infoPanel.style.display = 'block';
    updateInfoUI();
  } else {
    infoPanel.style.display = 'none';
  }

  // noise pixels
  noiseTime += 0.6;
  if(noiseTime > 10000) noiseTime = 0;
  for(let i=0;i<8;i++){
    const nx = cx + Math.cos((i*23 + noiseTime*6)/12) * (maxR * (0.2 + 0.8*Math.random()));
    const ny = cy + Math.sin((i*17 + noiseTime*5)/10) * (maxR * (0.2 + 0.8*Math.random()));
    ctx.fillStyle = 'rgba(0,255,140,0.02)';
    ctx.fillRect(nx, ny, 1, 1);
  }

  // beep logic driven by RAF (so dragging doesn't interrupt)
  const nowMs = performance.now();
  if(powerOn && artifact.proximity >= 100){
    if(!continuousOsc && audioCtx && isAudioEnabled) startContinuousTone();
    ledEl.classList.add('on');
  } else {
    if(continuousOsc) stopContinuousTone();
    if(powerOn && artifact.proximity > 0 && isAudioEnabled && audioCtx){
      const interval = proxToInterval(artifact.proximity);
      if(!lastBeepTime) lastBeepTime = nowMs;
      if(nowMs - lastBeepTime >= interval){
        playBeep();
        lastBeepTime = nowMs;
        ledEl.classList.add('on');
        ledFlashUntil = nowMs + Math.max(60, BEEP_DURATION);
      }
      if(nowMs > ledFlashUntil) ledEl.classList.remove('on');
    } else {
      if(!continuousOsc) ledEl.classList.remove('on');
      lastBeepTime = nowMs;
    }
  }

  // power overlay display
  if(!powerOn) powerOverlay.classList.remove('hidden');
  else powerOverlay.classList.add('hidden');

  requestAnimationFrame(draw);
}

/* small helpers */
function degToRad(d){ return d * Math.PI/180; }
function lerp(a,b,t){ return a + (b-a)*t; }
function angleDiff(a,b){ let d = (((a - b + 540) % 360) - 180); return d; }
function lerpAngle(a,b,t){ const diff = angleDiff(b,a); return (a + diff * t + 360) % 360; }

/* startup */
ensureAudio();
randomizeArtifact();
draw();

/* convenience listeners and initial UI */
directionEl.addEventListener('change', ()=>{ dirValEl.textContent = Math.round((directionEl.value/100)*360) + "° (slider)"; });
proximityEl.addEventListener('change', ()=>{ proxValEl.textContent = proximityEl.value; });

/* done */
</script>
</body>
</html>
